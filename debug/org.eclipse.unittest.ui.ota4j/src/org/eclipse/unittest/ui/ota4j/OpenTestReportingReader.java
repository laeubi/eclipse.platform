/*******************************************************************************
 * Copyright (c) 2025 Eclipse contributors and others.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Eclipse contributors - initial API and implementation
 *******************************************************************************/
package org.eclipse.unittest.ui.ota4j;

import java.io.IOException;
import java.io.Reader;
import java.time.Duration;
import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;

import org.eclipse.unittest.model.ITestElement;
import org.eclipse.unittest.model.ITestElement.FailureTrace;
import org.eclipse.unittest.model.ITestElement.Result;
import org.eclipse.unittest.model.ITestRunSession;
import org.eclipse.unittest.model.ITestSuiteElement;

/**
 * Reads Open Test Reporting events from an XML stream and translates them into
 * calls to the Unit Test API.
 * <p>
 * This class uses StAX (Streaming API for XML) to process events efficiently
 * with a low memory footprint, suitable for streaming test results.
 * </p>
 *
 * @since 1.0
 */
public class OpenTestReportingReader {

	private static final String EVENTS_NS = "https://schemas.opentest4j.org/reporting/events/0.2.0";
	private static final String CORE_NS = "https://schemas.opentest4j.org/reporting/core/0.2.0";

	private final ITestRunSession fSession;
	private final Map<String, ITestElement> fTestElements;
	private final Map<String, Instant> fTestStartTimes;
	private boolean fSessionStarted;

	/**
	 * Creates a new reader for Open Test Reporting events.
	 *
	 * @param session the test run session to update
	 */
	public OpenTestReportingReader(ITestRunSession session) {
		fSession = session;
		fTestElements = new HashMap<>();
		fTestStartTimes = new HashMap<>();
		fSessionStarted = false;
	}

	/**
	 * Reads Open Test Reporting events from the given reader and updates the test
	 * session accordingly.
	 *
	 * @param reader the reader providing the XML event stream
	 * @throws IOException        if an I/O error occurs
	 * @throws XMLStreamException if an error occurs while parsing the XML
	 */
	public void readEvents(Reader reader) throws IOException, XMLStreamException {
		XMLInputFactory factory = XMLInputFactory.newInstance();
		XMLStreamReader xmlReader = factory.createXMLStreamReader(reader);

		try {
			processEvents(xmlReader);
		} finally {
			xmlReader.close();
		}
	}

	private void processEvents(XMLStreamReader reader) throws XMLStreamException {
		Integer totalCount = null;

		while (reader.hasNext()) {
			int eventType = reader.next();

			if (eventType == XMLStreamConstants.START_ELEMENT) {
				String localName = reader.getLocalName();
				String namespace = reader.getNamespaceURI();

				if (EVENTS_NS.equals(namespace)) {
					switch (localName) {
					case "started":
						processStartedEvent(reader);
						break;
					case "reported":
						processReportedEvent(reader);
						break;
					case "finished":
						processFinishedEvent(reader);
						break;
					case "events":
						// Root element, continue
						break;
					default:
						// Unknown element, skip
						break;
					}
				}
			}
		}
	}

	private void processStartedEvent(XMLStreamReader reader) throws XMLStreamException {
		String id = reader.getAttributeValue(null, "id");
		String parentId = reader.getAttributeValue(null, "parentId");
		String name = reader.getAttributeValue(null, "name");
		String timeStr = reader.getAttributeValue(null, "time");

		Instant startTime = timeStr != null ? Instant.parse(timeStr) : Instant.now();
		fTestStartTimes.put(id, startTime);

		// Notify session started on first test element if not already started
		ensureSessionStarted();

		// Read the TestInfo content
		TestInfo testInfo = readTestInfo(reader);

		ITestSuiteElement parent = null;
		if (parentId != null) {
			ITestElement parentElement = fTestElements.get(parentId);
			if (parentElement instanceof ITestSuiteElement) {
				parent = (ITestSuiteElement) parentElement;
			}
		}

		// Determine if this is a test case or test suite.
		// In OTA4J, tests with a parent are typically leaf test cases,
		// while tests without a parent are typically test suites or containers.
		// Note: This is a simplified heuristic. More sophisticated frameworks
		// may have nested suites, which would require examining the test structure
		// or metadata to distinguish properly. For now, we use the presence of
		// a parent as the primary indicator.
		ITestElement element;
		if (parent != null) {
			// Has a parent - likely a test case
			element = fSession.newTestCase(id, name, parent, name, null);
		} else {
			// No parent - this is a test suite (or root test)
			element = fSession.newTestSuite(id, name, null, null, name, null);
		}

		fTestElements.put(id, element);
		fSession.notifyTestStarted(element);
	}

	/**
	 * Ensures the test session has been started. This should be called before
	 * processing the first test element.
	 */
	private void ensureSessionStarted() {
		if (!fSessionStarted) {
			fSession.notifyTestSessionStarted(null);
			fSessionStarted = true;
		}
	}

	private void processReportedEvent(XMLStreamReader reader) throws XMLStreamException {
		// Reported events can contain progress updates or partial results
		// For now, we'll skip these as the basic model doesn't support them
		skipElement(reader);
	}

	private void processFinishedEvent(XMLStreamReader reader) throws XMLStreamException {
		String id = reader.getAttributeValue(null, "id");
		String timeStr = reader.getAttributeValue(null, "time");

		Instant endTime = timeStr != null ? Instant.parse(timeStr) : Instant.now();

		ITestElement element = fTestElements.get(id);
		if (element == null) {
			skipElement(reader);
			return;
		}

		// Read the TestInfo content to get result information
		TestInfo testInfo = readTestInfo(reader);

		// Duration is calculated by the framework based on start/end notifications

		// Process result
		if (testInfo.result != null) {
			switch (testInfo.result.status) {
			case "SUCCESSFUL":
				fSession.notifyTestEnded(element, false);
				break;
			case "SKIPPED":
				fSession.notifyTestEnded(element, true);
				break;
			case "FAILED":
				FailureTrace trace = new FailureTrace(testInfo.result.reason != null ? testInfo.result.reason : "",
						null, null);
				fSession.notifyTestFailed(element, Result.FAILURE, false, trace);
				fSession.notifyTestEnded(element, false);
				break;
			case "ERRORED":
				FailureTrace errorTrace = new FailureTrace(
						testInfo.result.reason != null ? testInfo.result.reason : "", null, null);
				fSession.notifyTestFailed(element, Result.ERROR, false, errorTrace);
				fSession.notifyTestEnded(element, false);
				break;
			case "ABORTED":
				FailureTrace abortTrace = new FailureTrace(
						testInfo.result.reason != null ? testInfo.result.reason : "", null, null);
				fSession.notifyTestFailed(element, Result.ERROR, false, abortTrace);
				fSession.notifyTestEnded(element, false);
				break;
			default:
				fSession.notifyTestEnded(element, false);
				break;
			}
		} else {
			fSession.notifyTestEnded(element, false);
		}
	}

	private TestInfo readTestInfo(XMLStreamReader reader) throws XMLStreamException {
		TestInfo testInfo = new TestInfo();
		int depth = 1; // We're already inside the element

		while (reader.hasNext() && depth > 0) {
			int eventType = reader.next();

			if (eventType == XMLStreamConstants.START_ELEMENT) {
				String localName = reader.getLocalName();
				String namespace = reader.getNamespaceURI();

				if (CORE_NS.equals(namespace) && "result".equals(localName)) {
					testInfo.result = readResult(reader);
					depth++; // We'll close this in the END_ELEMENT
				} else {
					depth++;
				}
			} else if (eventType == XMLStreamConstants.END_ELEMENT) {
				depth--;
			}
		}

		return testInfo;
	}

	private ResultInfo readResult(XMLStreamReader reader) throws XMLStreamException {
		ResultInfo result = new ResultInfo();
		result.status = reader.getAttributeValue(null, "status");

		while (reader.hasNext()) {
			int eventType = reader.next();

			if (eventType == XMLStreamConstants.START_ELEMENT) {
				String localName = reader.getLocalName();
				if ("reason".equals(localName)) {
					result.reason = readTextContent(reader);
				}
			} else if (eventType == XMLStreamConstants.END_ELEMENT
					&& "result".equals(reader.getLocalName())) {
				break;
			}
		}

		return result;
	}

	private String readTextContent(XMLStreamReader reader) throws XMLStreamException {
		StringBuilder content = new StringBuilder();

		while (reader.hasNext()) {
			int eventType = reader.next();

			if (eventType == XMLStreamConstants.CHARACTERS || eventType == XMLStreamConstants.CDATA) {
				content.append(reader.getText());
			} else if (eventType == XMLStreamConstants.END_ELEMENT) {
				break;
			}
		}

		return content.toString();
	}

	private void skipElement(XMLStreamReader reader) throws XMLStreamException {
		int depth = 1;

		while (reader.hasNext() && depth > 0) {
			int eventType = reader.next();

			if (eventType == XMLStreamConstants.START_ELEMENT) {
				depth++;
			} else if (eventType == XMLStreamConstants.END_ELEMENT) {
				depth--;
			}
		}
	}

	private static class TestInfo {
		ResultInfo result;
	}

	private static class ResultInfo {
		String status;
		String reason;
	}
}
